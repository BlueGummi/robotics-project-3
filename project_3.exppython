{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nleft_drive_smart = Motor(Ports.PORT3, False)\nright_drive_smart = Motor(Ports.PORT8, True)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 319.19, 320, 40, MM, 1)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n\n# Initialize random seed \ninitializeRandomSeed()\n\nvexcode_initial_drivetrain_calibration_completed = False\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    global vexcode_initial_drivetrain_calibration_completed\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    vexcode_initial_drivetrain_calibration_completed = True\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n\n# Calibrate the Drivetrain\ncalibrate_drivetrain()\n\n#endregion VEXcode Generated Robot Configuration\n\n#\n# Copyright (c) 2026 Team VMPSADBW\n# All rights reserved.\n#\n# This code is licensed under the BSD 3-Clause License.\n#\n\n# Before we start, let's define the layout for this file\n#\n# We are taking on this structure of a monolithic self-contained python file to make everyone's life\n# a little easier, since one can simply share this singular file\n#\n# DOCUMENTATION - Comments explaining the high-level \"Design\" of this file, further comments will be found later on in CODE\n#\n# IMPORTS - our library imports\n#\n# UNMODIFIABLE CONSTANTS - for things like sentinel values, prefixed with CONST_\n#\n# CONFIGURATION - global CONFIG_ variables\n#\n# CODE - Implementation\n#\n#        Throughout CODE, init code will be sprinkled around to initialize and declare global variables.\n#        HOWEVER, no actual code will run until the very end of the section.\n#\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- DOCUMENTATION ----------------------------------\n#\n#\n#\n#\n#\n#\n\n# IMPORTANT NOTES\n# Global variables with `_` prefixed in their name should NOT\n# be modified from other systems. Only modify global variables prefixed with `CONFIG_`.\n# \n# This version of MicroPython that Vex uses does NOT SUPPORT F STRINGS!!! <-- found this out after much pain\n#\n# ERROR HANDLING\n# We will be using a custom `robo_assert` as opposed to the error `raise` paradigm of Python.\n# This is because with the `raise` paradigm, we are either relying on the caller to always\n# remember to `try...catch`, or are relying on one big `try...catch` in the main outer loop.\n#\n# This kind of code structure can easily break from a forgotten statement, and such moments\n# can lead to undefined behavior within the robot. Thus, we choose to use `robo_assert` as it\n# gives us strict determinism, and isolates our code's errors from the robot's errors, as we can\n# know that any `raise` would not arise from errors that we created (since we go through `robo_assert`)\n#\n# `robo_assert` takes in an asserted statement, panic reason, and message, in that order\n#\n# panic reasons are defined in `class PanicReason`\n#\n# Printing to the console is done through `print_message`. All `log_` functionality is purely for the logging system\n#\n#\n#\n#\n#\n# CODE STYLE\n# NOTE: THIS PLATFORM DOES NOT SUPPORT THE `typing` MODULE. THERE IS NO TYPE SAFETY. \n#\n#\n#\n#\n#\n# REST OF DOCS\n#\n# Our primary goal of this is to find a way to construct arbitrary paths between points\n# on a weighted grid. The grid size is defined by CONFIG_MAP_WIDTH and CONFIG_MAP_HEIGHT.\n#\n# Grid coordinates are structured as follows:\n#\n#\n# +y\n#\n# |\n# |\n# |\n# |\n# |\n# |\n# 0 ---------------- +x\n#\n# The bottom left is the origin, and it increases in the X direction going right, and the Y direction going up.\n#\n# NOTE: Gridlines are formed along the lines of tiles, NOT their centers. This means that the walls adjacent to\n# the origin are the X and Y axes.\n#\n# We will use the A* pathfinding algorithm, as this is weighted (if it wasn't weighted, we could probably do Jump Point Search)\n#\n# There are two main classes: `class Robot` and `class Path`. The `Robot` class is used to abstract over our Brain and Drivetrain\n# There are more internal classes, but don't worry about those as much, as those are not as core to the functionality\n#\n# CONTROL PARADIGM:\n# \n# The robot starts powered off. After powering on, it needs to be calibrated. As the voice says, press \"B\" to calibrate\n# it. This will reset sensors and motors to their initial states, and the robot's internal heading to North and position\n# to \"0,0\". Once this is done, the robot will enter a menu. Navigating through this menu will allow you to find your\n# designated destination.\n#\n# CONTROL NOTES:\n# \n# Vex is weird and doesn't allow us to unregister a callback (???), thus, we model a state machine of the robot, and \n# we make a callback for the functionality of all relevant buttons at each state, and inside the callback we check if \n# the expected state matches the current state and only operate if they do match. \n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n\n\n\n\n\n\n\n\n\n#\n#\n#\n#\n#\n#\n#\n# ---------------------------------- IMPORTS ----------------------------------\n#\n#\n#\n#\n#\n#\n\n# nothing for now\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CONSTANTS ----------------------------------\n#\n#\n#\n#\n#\n#\n\n\nCONST_WEIGHT_UNTRAVERESABLE = -1\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CONFIG ----------------------------------\n#\n#\n#\n#\n#\n#\n\nCONFIG_DEBUG = (\n    True  # Defines if we are in a debug build. More logging functionality will be enabled if we are, but this\n)         # may come at the cost of slowing down the program due to the instrumentation\n\nCONFIG_SPIN_LATENCY_MS = 5 # Spinning/waiting in a loop - how long should we wait each iteration?\n\nCONFIG_AUDIO_DIR = \"\" # only if the audio on the microSD is under some directory\nCONFIG_MAP_WIDTH = 7  # Map width in units.\nCONFIG_MAP_HEIGHT = 7  # Map height in units.\n\nCONFIG_MAP_TILE_WIDTH_INCHES = 24\nCONFIG_MAP_TILE_HEIGHT_INCHES = 24\n\n# definition:\n#    LOG_TRACE = 0  # Trace events\n#    LOG_DEBUG = 1  # Debugging messages\n#    LOG_WARN = 2  # Warnings\n#    LOG_ERR = 3  # Fatal errors (these do NOT panic, however)\n\nCONFIG_PRINT_LOG_DEPTH = 0 # The deepest log we should still print\n\n# TODO: Figure out what the robot's memory usage limitations are\n\n# These two variables exist to limit the size of the map.\n# The limits exist because internally we construct a large 2D array of `Tile`s to represent the map.\n# Computers have limited memory, so eventually it will OOM,\n# and these just exist to make sure we can safely exit before that happens\nCONFIG_CONST_MAX_WIDTH = 128\nCONFIG_CONST_MAX_HEIGHT = 128\n\nCONFIG_FONT = FontType.MONO12 # Please change CONFIG_FONT_ROWS and CONFIG_FONT_COLS according to the\n                              # table listed in brain.scree.next_row()'s documentation file!\nCONFIG_FONT_ROWS = 9\nCONFIG_FONT_COLS = 26\nCONFIG_TURN_COST = 5 # Used in A*\n\n# This is an array of arrays of (weight, x, y). We parse this one time at init to label the obstacles on our map.\nCONFIG_MAP_OBSTACLES = [\n    [CONST_WEIGHT_UNTRAVERESABLE, 3, 1],\n    [CONST_WEIGHT_UNTRAVERESABLE, 2, 6],\n    [CONST_WEIGHT_UNTRAVERESABLE, 3, 3],\n    [CONST_WEIGHT_UNTRAVERESABLE, 5, 2],\n]  # Houses A, B, C, and D respectively\n\n# This is an array of arrays of (name: str, audio_file: str, x, y)\nCONFIG_MAP_LOCATIONS = [\n    [\"House A\", \"house_a.wav\", 3, 1],\n    [\"House B\", \"house_b.wav\", 2, 6],\n    [\"House C\", \"house_c.wav\", 3, 3],\n    [\"House D\", \"house_d.wav\", 5, 2]\n]\n\nCONFIG_SOUND_VOL = 50 # Range 0-100\n\n# TODO: more configs for robot/arm speed and whatnot as they come about\n\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CODE ----------------------------------\n#\n#\n#\n#\n#\n#\n\n\n#\n#\n# --------- Handrolling things that this environment doesn't have ---------\n#\n#\n\nclass FakeIntEnum:\n    @classmethod\n    def name(cls, value):\n        for attr, val in cls.__dict__.items():\n            if not attr.startswith(\"_\") and not callable(val) and val == value:\n                return attr\n        return None\n\nclass heapq:\n    def __init__(self):\n        self.data = []\n\n    def heappush(self, item):\n        self.data.append(item)\n        self.data.sort(key=lambda x: x[0])\n\n    def heappop(self):\n        return self.data.pop(0)\n\n    def __bool__(self):\n        return len(self.data) > 0\n\n#\n#\n# --------- ERROR HANDLING, AUDIO, AND INIT CODE ---------\n#\n#\n\n\n# Class definitions for error handling and init code\nclass InitStage(FakeIntEnum):\n    INIT_CODE = 0  # Default init stage, only code is being set up\n    INIT_ROBOT = 1  # Initializing the robot to a known state\n    INIT_RUNNING = 2  # All systems go! (hopefully)\n\nclass PanicPhase(FakeIntEnum):\n    PANIC_STOP_MOTION = 10  # Stop anything that might be running constantly\n    PANIC_SNAPSHOT_STATE = 20  # In case we need to know the current positions of things\n    PANIC_USER_DEBUG = 30  # Start the unwind and potentially enter a debug shell\n    PANIC_HALT = 40  # bye bye, basically the program halt\n\nclass PanicReason(FakeIntEnum):\n    PANIC_UNKNOWN = 0\n\n    PANIC_MAP_OOB = 10\n    PANIC_MAP_CORRUPT = 11\n\n    PANIC_PATH_INVALID = 20\n    PANIC_PATH_NO_NEIGHBOR = 21\n\n    PANIC_ROBOT_ILLEGAL_MOVE = 30\n    PANIC_ROBOT_STATE_INVALID = 31\n\n    PANIC_COORD_INVALID = 40\n\n    PANIC_INTERNAL_INVARIANT = 100\n\nclass PanicCallback:\n    def __init__(\n        self,\n        name,\n        phase,\n        fn,\n        priority = 0,\n    ):\n        self.name = name\n        self.phase = phase\n        self.priority = priority\n        self.fn = fn\n\n# Init stage\n_INIT_STAGE = InitStage.INIT_CODE\ndef init_advance(stage):\n    global _INIT_STAGE\n    _INIT_STAGE = stage\n\ndef spin_wait():\n    wait(CONFIG_SPIN_LATENCY_MS, MSEC)\n\ndef play_audio(fname):\n    if fname is None:\n        return\n\n    if CONFIG_AUDIO_DIR != \"\":\n        raw_path = CONFIG_AUDIO_DIR + \"/\" + fname\n    else:\n        raw_path = fname\n\n    if brain.sdcard.exists(raw_path):\n        brain.play_file(raw_path, CONFIG_SOUND_VOL)\n        while brain.sound_is_active():\n            spin_wait()\n\ndef speak_number(num):\n    def speak_word(word):\n        play_audio(\"num_\" + word + \".wav\")\n\n    ones = [ # I know this is silly but this used to convert\n             # into english words rather than numbers, (e.g. 0 -> \"zero\")\n             # and now I am too lazy to change it again\n        \"\",\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"10\",\n        \"11\",\n        \"12\",\n        \"13\",\n        \"14\",\n        \"15\",\n        \"16\",\n        \"17\",\n        \"18\",\n        \"19\",\n    ]\n\n    tens = [\n        \"\",\n        \"\",\n        \"20\",\n        \"30\",\n        \"40\",\n        \"50\",\n        \"60\",\n        \"70\",\n        \"80\",\n        \"90\",\n    ]\n\n    print_message(str(num))\n    if num < 0 or num >= 1000:\n        return\n\n    if num == 0:\n        return speak_word(\"0\")\n\n    if num >= 100:\n        one_part = ones[num / 100]\n        speak_word(one_part)\n        speak_word(\"100\")\n        num %= 100\n        if num > 0:\n            speak_word(\"and\")\n\n    if num >= 20:\n        speak_word(tens[num / 10])\n        num %= 10\n        if num > 0:\n            speak_word(ones[num])\n    elif num > 0:\n        speak_word(ones[num])\n\n\ndef get_time_ms():\n    return brain.timer.time(MSEC)\n\ndef print_message(msg = \"\"):\n    print(msg)\n    robot_render_pos()\n    brain.screen.print(msg)\n    brain.screen.next_row()\n\ndef clear_console():\n    brain.screen.clear_screen()\n    robot_render_pos()\n\n\n# This will terminate the program, it is UNSAFE to call from arbitrary points, and should only be invoked\n# from within `panic` unless something truly awful has happened and we cannot recover anything (unlikely)\ndef halt_and_catch_fire():\n    brain.program_stop()\n\n_PANIC_CALLBACKS = []\ndef panic(reason):\n    print_message('PANIC \"%s\"' % (reason))\n\n    callbacks = sorted(\n        _PANIC_CALLBACKS,\n        key=lambda c: (c.phase, -c.priority),\n    )\n\n    for cb in callbacks:\n        if CONFIG_DEBUG:\n            print_message(\"panic: %s:%s\" % (PanicPhase.name(cb.phase), cb.name))\n        cb.fn()\n\n    halt_and_catch_fire()\n\n\ndef panic_callback_register(cb):\n    _PANIC_CALLBACKS.append(cb)\n\n\n# USE THIS to assert conditions\ndef robo_assert(condition, reason, msg = \"\"):\n    if condition:\n        return\n\n    play_audio(\"halt_assertion_failure.wav\") # TODO: maybe someone can find a smarter way \n                                             # of doing audio files and not making\n                                             # a million CONFIG_*s.... \n    panic(\"%s: %s\" % (PanicReason.name(reason), msg))\n\n#\n#\n# --------- MAIN LOGIC ---------\n#\n#\n\n\n# Types (unused, typing doesn't work)\n# Coord = (int, int)  # x, y\n# TileWeight = int\n# Direction = (int, int)\n\nclass LogType(FakeIntEnum):\n    LOG_TRACE = 0  # Trace events\n    LOG_DEBUG = 1  # Debugging messages\n    LOG_WARN = 2  # Warnings\n    LOG_ERR = 3  # Fatal errors (these do NOT panic, however)\n\n\n_LOGS = []\nclass Log:\n    def __init__(self, log_type, message = \"\"):\n        self.log_type = log_type\n        self.message = message\n        self.timestamp = get_time_ms()\n\n    \n\ndef log_event(log_type, message = \"\"):\n    if log_type >= CONFIG_PRINT_LOG_DEPTH:\n        print(LogType.name(log_type) + \": \" + message)\n    _LOGS.append(Log(log_type, message))\n\n\n# A \"Tile\" structure, this has a weight, which we define with __slots__\n# because there will be a LOT of these, and this is the only thing that a tile has.\nclass Tile:\n    __slots__ = (\"weight\")\n\n    def __init__(self, weight):\n        self.weight = weight\n\n    # Negative weights are completely untraversable\n    @property\n    def traversable(self):\n        return self.weight >= 0\n\n    @property\n    def cost(self):\n        return self.weight\n\n\n# A \"GridMap\" structure to represent all the Tiles of the map\nclass GridMap:\n    def __init__(self, width, height):\n        robo_assert(\n            width <= CONFIG_CONST_MAX_WIDTH and height <= CONFIG_CONST_MAX_HEIGHT,\n            PanicReason.PANIC_MAP_OOB,\n            \"map size exceeds hard limits\",\n        )\n        self.width = width\n        self.height = height\n\n        # indexed as [y][x], or [row][col]\n        self.tiles = [\n            [Tile(1) for _ in range(width + 1)] for _ in range(height + 1)\n        ]\n\n    def in_bounds(self, coord):\n        x, y = coord\n        return 0 <= x <= self.width and 0 <= y <= self.height\n\n    def tile(self, coord):\n        x, y = coord\n        return self.tiles[y][x]\n\n    def neighbors(self, coord):\n        x, y = coord\n        candidates = [\n            (x + 1, y),  # eastern one\n            (x - 1, y),  # western one\n            (x, y + 1),  # northern one\n            (x, y - 1),  # southern one\n        ]\n\n        result = []\n        for c in candidates:\n            if self.in_bounds(c) and self.tile(c).traversable:\n                result.append(c)\n\n        return result\n\ndef print_grid(grid, path=None):\n    path_set = set(path) if path else set()\n\n    for y in range(grid.height + 1):\n        row = \"\"\n        for x in range(grid.width + 1):\n            coord = (x, y)\n            tile = grid.tile(coord)\n            if coord in path_set:\n                row += \"P\"  # path tile\n            elif not tile.traversable:\n                row += \"B\"  # blocked\n            elif tile.cost > 1:\n                row += \"E\"  # expensive tile\n            else:\n                row += \".\"  # normal tile\n        print(row)\n\n\n\n_LOCATIONS = [] # List of Locations to add in the menu\nclass Location:\n    def __init__(self, name, audio_file, coordinate):\n        self.name = name\n        self.audio_file = audio_file\n        self.coords = coordinate\n\n    def speak(self):\n        play_audio(self.audio_file)\n\ndef parse_locations():\n    for location in CONFIG_MAP_LOCATIONS:\n        name = location[0]\n        audio_file = location[1]\n        x = location[2]\n        y = location[3]\n        lclass = Location(name, audio_file, (x, y))    \n        _LOCATIONS.append(lclass)\n\ndef menu_from_locations():\n    return Menu(_LOCATIONS)\n\n# Menu:\n#                          \n#      ┌───────────────┐   \n#      │Display Current│   \n#   ┌─▶│  Destination  │◀─┐\n#   │  └───────────────┘  │\n#   │          │          │\n#   │          │          │\n#   └───Prev───┼───Next───┘\n#              │           \n#            Select        \n#              │           \n#              │           \n#              ▼           \n#    ┌───────────────────┐ \n#    │Travel to selection│ \n#    └───────────────────┘ \n\nclass MenuState(FakeIntEnum):\n    MENU_DISPLAY = 0\n    MENU_SELECTED = 1\n\nclass Menu:\n    def __init__(self, locations):\n        robo_assert(len(locations) > 0, PanicReason.PANIC_INTERNAL_INVARIANT, \n                    \"Menu must have at least one location\")\n        self.locations = locations\n        self.current_location = locations[0]\n        self.current_location_index = 0\n        self.number_locations = len(locations)\n        self.state = MenuState.MENU_DISPLAY\n        self.data_changed = True \n\n    def present(self):\n        if self.data_changed:\n            clear_console()\n        \n            brain.screen.set_cursor(3, 1)\n            brain.screen.print(\"Menu:\")\n            brain.screen.next_row()\n            brain.screen.print(\"  < \" + self.current_location.name + \" >\")\n            brain.screen.next_row()\n        \n            self.data_changed = False\n\n\n    # Internal. use scroll_right/left from the outside world\n    def _scroll(self, direction):\n        if direction:\n            advance = 1\n        else:\n            advance = -1\n        \n        self.current_location_index = ((self.current_location_index + advance)\n                                        % self.number_locations)\n        self.current_location = self.locations[self.current_location_index]\n        self.data_changed = True\n\n    def scroll_right(self):\n        self._scroll(True)\n    \n    def scroll_left(self):\n        self._scroll(False)\n    \n    def select(self):\n        self.state = MenuState.MENU_SELECTED\n\n    def enter(self, should_play_sound=True):\n        log_event(LogType.LOG_TRACE, \"Entering menu\")\n        controller.buttonDown.pressed(self.scroll_left)\n        controller.buttonUp.pressed(self.scroll_right)\n        controller.buttonA.pressed(self.select)\n        controller.buttonB.pressed(self.select)\n        if should_play_sound:\n            play_audio(\"menu_enter.wav\")\n\n        while self.state != MenuState.MENU_SELECTED:\n            self.present()\n            spin_wait()\n\n        self.state = MenuState.MENU_DISPLAY\n        play_audio(\"destination_set.wav\")\n        play_audio(self.current_location.audio_file)\n        log_event(LogType.LOG_TRACE, \"Destination set to \" + self.current_location.name)\n        clear_console()\n        return self.current_location\n\n\n# No need to use __slots__ here, since these structures aren't as frequently\n# instantiated, and we might end up adding extra properties later on\nclass Path:\n    def __init__(self, points):\n        robo_assert(\n            len(points) != 0, PanicReason.PANIC_PATH_INVALID, \"path must have points\"\n        )\n        self.points = points\n\n    @property\n    def start(self):\n        return self.points[0]\n\n    @property\n    def end(self):\n        return self.points[-1]\n\n    def __len__(self):\n        return len(self.points)\n\n    def __iter__(self):\n        return iter(self.points)\n\n\n# ---------------------- ROBOT STATE MACHINE ----------------------\n#                         ┌───────────────┐                           \n#                         │               │                           \n#             ┌─INIT FAIL─│    STOPPED    │──INIT OK──┐               \n#             │           │               │           │               \n#             │           └───────────────┘           │               \n#             │                   ▲                   │               \n#             ▼                   │                   ▼               \n#   ┌───────────────────┐         │         ┌───────────────────┐     \n#   │                   │         │         │                   │     \n#   │    FAILED INIT    │         │         │    INITIALIZED    │     \n#   │                   │         │         │                   │     \n#   └───────────────────┘         │         └───────────────────┘     \n#             │                   │                   │               \n#             │                   │               ENTER MENU          \n#             └──RETURN BACK TO───┘                   ▼               \n#                                           ┌──────────────────┐      \n#                                           │                  │      \n#             ┌──RE-ENTER MENU──┬──────────▶│  SELECTION MENU  │◀─┐   \n#             │                 │           │                  │  │   \n#   ┌───────────────────┐       │           └──────────────────┘  │   \n#   │                   │       │                     │           │   \n#   │  DELIVER PACKAGE  │   PATH FAIL                 │           │   \n#   │                   │       │                     ├────STAY───┘   \n#   └───────────────────┘       │                     │               \n#             ▲                 │                     │               \n#             │          ┌────────────┐               │               \n#             │          │            │               │               \n#             └─PATH OK──│   TRAVEL   │◀───SELECTED───┘               \n#                        │            │                               \n#                        └────────────┘                               \n#                                                                     \n#                                                                     \n#                                ◎                                    \n#                                ╳                                    \n#                           STOP SIGNAL                               \n#                         (can arrive at                              \n#                            any time)                                \n#                                ╳                                    \n#                                ▼                                    \n#                        ┌───────────────┐                            \n#                        │               │                            \n#                        │    STOPPED    │                            \n#                        │               │                            \n#                        └───────────────┘                            \n\nclass RobotState(FakeIntEnum):\n    ROBOT_FAILED_INIT = -1\n    ROBOT_STOPPED = 0\n    ROBOT_INITIALIZED = 1\n    ROBOT_IN_MENU = 2\n    ROBOT_TRAVELLING = 3\n    ROBOT_DELIVERING = 4\n\nclass Robot:\n    def __init__(self, start):\n        self.position = start\n        self.state = RobotState.ROBOT_STOPPED\n    \n    def change_state(self, new_state):\n        log_event(LogType.LOG_TRACE, \"Robot state change %s -> %s\" \n                    % (RobotState.name(self.state), RobotState.name(new_state)))\n        self.state = new_state\n    \n    def get_pos(self):\n        return self.position\n\n    def can_step_to(self, target):\n        x1, y1 = self.position\n        x2, y2 = target\n        return abs(x1 - x2) + abs(y1 - y2) == 1\n\n    def follow_path(self, path):\n        robo_assert(\n            path.start == self.position,\n            PanicReason.PANIC_PATH_INVALID,\n            \"path start %s does not match robot position %s\" % (path.start, self.position),\n        )\n\n        self.change_state(RobotState.ROBOT_TRAVELLING)\n\n        for next_coord in path.points[1:]:\n            robo_assert(\n                self.can_step_to(next_coord),\n                PanicReason.PANIC_PATH_INVALID,\n                \"impossible move from %s to %s\" % (self.position, next_coord),\n            )\n\n            self._move_to(next_coord)\n\n    def _move_to(self, coord):\n        if CONFIG_DEBUG:\n            print_message(\"moving from %s to %s\" % (self.position, coord))\n\n        # TODO: Drivetrain\n        self.position = coord\n    \n\n\ndef reconstruct_path(came_from, current):\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    path.reverse()\n    return path\n\n\n# manhattan distance as we restrict ourselves to horizontal and vertical\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(\n        a[1] - b[1]\n    )  # imagine having an algorithm named after your bad urban planning\n\n\ndef build_map_from_config():\n    grid = GridMap(CONFIG_MAP_WIDTH, CONFIG_MAP_HEIGHT)\n\n    for entry in CONFIG_MAP_OBSTACLES:\n        weight, x, y = entry\n        coord = (x, y)\n\n        robo_assert(\n            grid.in_bounds(coord),\n            PanicReason.PANIC_MAP_CORRUPT,\n            \"obstacle out of bounds: %d, %d\" % (coord[0], coord[1]),\n        )\n\n        grid.tile(coord).weight = weight\n\n    return grid\n\n# We're using an A* algorithm here to pathfind, however we implemented very strong bias\n# towards avoiding turning and preferring direct straight lines for error minimization\n\n# As an effect of this, this algorithm often behaves identically to a much simpler, more\n# naive \"drive forward to the right row, turn right, drive to right column\", especially\n# on smaller (e.g. 6x6) maps that have smaller turn costs.\n\n# However, we will preserve the use of A* in case we want to experiment with treating\n# smaller units as \"tiles\" (e.g. one virtual tile is not a physical tile on the ground)\n\n\n# This algorithm can also be unbiased to test different degrees of turn costs to time efficiency\ndef astar_internal(\n    grid,\n    start,\n    goal,\n    turn_cost = CONFIG_TURN_COST,\n    start_dir = None,\n):\n    log_event(LogType.LOG_DEBUG, \"astar_with_directions called: start=%s, goal=%s, start_dir=%s, turn_cost=%s\" %\n              (start, goal, start_dir, turn_cost))\n\n    robo_assert(\n        grid.in_bounds(start) and grid.in_bounds(goal),\n        PanicReason.PANIC_COORD_INVALID,\n        \"start or goal out of bounds\",\n    )\n\n    end_tile_changed = False\n    if not grid.tile(goal).traversable:\n        grid.tile(goal).weight = 0\n        end_tile_changed = True\n\n    if not grid.tile(start).traversable:\n        return None\n\n    # (f_score, Coord)\n    open_heap = heapq()\n    heapq.heappush(open_heap, (0, start))\n\n    # path reconstruction\n    came_from = {}\n    came_from_dir = {}\n\n    if start_dir is not None:\n        came_from_dir[start] = start_dir\n\n    g_score = {start: 0}\n\n    def get_direction(a, b):\n        return (b[0] - a[0], b[1] - a[1])\n\n    while open_heap:\n        _, current = heapq.heappop(open_heap)\n\n        if current == goal:\n            path = Path(reconstruct_path(came_from, current))\n            log_event(LogType.LOG_TRACE, \"found path\")\n            \n            if end_tile_changed:\n                grid.tile(goal).weight = -1\n            \n            return path\n\n        for neighbor in grid.neighbors(current):\n            tentative_g = g_score[current] + grid.tile(neighbor).cost\n            move_dir = get_direction(current, neighbor)\n            prev_dir = came_from_dir.get(current)\n\n            if prev_dir is not None and move_dir != prev_dir:\n                tentative_g += turn_cost\n\n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                came_from[neighbor] = current\n                came_from_dir[neighbor] = move_dir\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(neighbor, goal)\n                heapq.heappush(open_heap, (f_score, neighbor))\n\n    if end_tile_changed:\n        grid.tile(goal).weight = -1\n\n    return None\n\ndef astar(grid, start, goal, turn_cost=CONFIG_TURN_COST, start_dir=None, tried_fallback=False):\n    path = astar_internal(grid, start, goal, turn_cost, start_dir)\n    \n    if path is not None:\n        return path\n\n    if not tried_fallback and turn_cost != 0:\n        log_event(LogType.LOG_WARN, \"No path found with turn_cost=%s, retrying with turn_cost=0\" % turn_cost)\n        return astar(grid, start, goal, turn_cost=0, start_dir=start_dir, tried_fallback=True)\n\n    return None\n\n\nGLOBAL_MAP = None\nROBOT = None\nMENU = None\n\ndef robot_render_pos():\n    # We always want to make the robot's internal position visible\n    # on the screen. We'll render this at the top left of the display.\n\n    # If the cursor was previously occupying the location of the coordinates,\n    # then we move the cursor down to no longer overwrite our coordinates.\n\n    # Otherwise, we'll just move the cursor down one row since we won't be\n    # overwriting the coordinates we just wrote to the screen\n    row = brain.screen.row()\n    col = brain.screen.column()\n    brain.screen.set_cursor(1, 1)\n    x, y = ROBOT.get_pos()\n    brain.screen.print(\"(\" + str(x) + \", \" + str(y) + \")\")\n\n    if row == 1:\n        brain.screen.next_row()\n    else:\n        brain.screen.set_cursor(row, col) # go back to where we were\n\n\ndef menu_right_callback():\n    if ROBOT.state == RobotState.ROBOT_IN_MENU:\n        MENU.scroll_right()\n\ndef menu_left_callback():\n    if ROBOT.state == RobotState.ROBOT_IN_MENU:\n        MENU.scroll_left()\n\ndef travel_to(target):\n    global GLOBAL_MAP\n    path = astar(GLOBAL_MAP, ROBOT.position, target.coords,\n                CONFIG_TURN_COST, 0)\n    \n    log_event(LogType.LOG_TRACE, \"Following path\")\n    ROBOT.follow_path(path)\n    play_audio(\"complete.wav\")\n\n    pass # TODO\n\n# THE BIG INIT - initialize in-software things BEFORE calibration \n# (i.e. initialize things that don't need user input)\ndef init():\n    parse_locations()\n    global GLOBAL_MAP, ROBOT, MENU\n    GLOBAL_MAP = build_map_from_config()\n    if CONFIG_DEBUG:\n        print_grid(GLOBAL_MAP)\n\n    ROBOT = Robot((0, 0))\n    MENU = menu_from_locations()\n    # Code init finished\n\n    # We first initialize software stuff before touching hardware\n    brain.screen.set_font(CONFIG_FONT)\n    init_advance(InitStage.INIT_ROBOT)\n\n    if CONFIG_DEBUG:\n        play_audio(\"debug_mode.wav\")\n    else:\n        play_audio(\"release_mode.wav\")\n\ndef calibrate():\n    if ROBOT.state != RobotState.ROBOT_STOPPED:\n        return\n    \n    brain_inertial.set_heading(0, DEGREES)\n    brain_inertial.set_rotation(0, DEGREES)\n    brain_inertial.calibrate()\n    ROBOT.change_state(RobotState.ROBOT_INITIALIZED)\n\ndef main():\n    init()\n    play_audio(\"on.wav\")\n\n    controller.buttonB.pressed(calibrate)\n\n    while ROBOT.state != RobotState.ROBOT_INITIALIZED:\n        spin_wait()\n\n    play_audio(\"initialized.wav\")\n    first_run = True\n\n    while True:\n        target = MENU.enter(first_run)\n        first_run = False\n        # This is the main loop. In here we want to select a target, go there,\n        # select a target again, and continue on and on\n        travel_to(target)\n\nif __name__ == \"__main__\":\n    main()","textLanguage":"python","robotConfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[3,8,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel4in","gearRatio":"1:1","direction":"fwd","gyroType":"integrated","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null}],"slot":0,"platform":"EXP","sdkVersion":"20240802.15.00.00","appVersion":"4.64.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}