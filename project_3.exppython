{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain = Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nleft_drive_smart = Motor(Ports.PORT3, False)\nright_drive_smart = Motor(Ports.PORT8, True)\ndrivetrain = SmartDrive(left_drive_smart, right_drive_smart, brain_inertial, 319.19, 320, 40, MM, 1)\n\n\n# Wait for sensor(s) to fully initialize\nwait(100, MSEC)\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n\n# Initialize random seed \ninitializeRandomSeed()\n\nvexcode_initial_drivetrain_calibration_completed = False\ndef calibrate_drivetrain():\n    # Calibrate the Drivetrain Inertial\n    global vexcode_initial_drivetrain_calibration_completed\n    sleep(200, MSEC)\n    brain.screen.print(\"Calibrating\")\n    brain.screen.next_row()\n    brain.screen.print(\"Inertial\")\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        sleep(25, MSEC)\n    vexcode_initial_drivetrain_calibration_completed = True\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n\n\n# Calibrate the Drivetrain\ncalibrate_drivetrain()\n\n#endregion VEXcode Generated Robot Configuration\n# Before we start, let's define the layout for this file\n#\n# We are taking on this structure of a monolithic self-contained python file to make everyone's life\n# a little easier, since one can simply share this singular file\n#\n# DOCUMENTATION - Comments explaining the high-level \"Design\" of this file, further comments will be found later on in CODE\n#\n# IMPORTS - our library imports\n#\n# UNMODIFIABLE CONSTANTS - for things like sentinel values, prefixed with CONST_\n#\n# CONFIGURATION - global CONFIG_ variables\n#\n# CODE - Implementation\n#\n#        Throughout CODE, init code will be sprinkled around to initialize and declare global variables.\n#        HOWEVER, no actual code will run until the very end of the section.\n#\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- DOCUMENTATION ----------------------------------\n#\n#\n#\n#\n#\n#\n\n# IMPORTANT NOTES\n# Global variables with `_` prefixed in their name should NOT\n# be modified from other systems. Only modify global variables prefixed with `CONFIG_`.\n# \n# This version of MicroPython that Vex uses does NOT SUPPORT F STRINGS!!! <-- found this out after much pain\n#\n# ERROR HANDLING\n# We will be using a custom `robo_assert` as opposed to the error `raise` paradigm of Python.\n# This is because with the `raise` paradigm, we are either relying on the caller to always\n# remember to `try...catch`, or are relying on one big `try...catch` in the main outer loop.\n#\n# This kind of code structure can easily break from a forgotten statement, and such moments\n# can lead to undefined behavior within the robot. Thus, we choose to use `robo_assert` as it\n# gives us strict determinism, and isolates our code's errors from the robot's errors, as we can\n# know that any `raise` would not arise from errors that we created (since we go through `robo_assert`)\n#\n# `robo_assert` takes in an asserted statement, panic reason, and message, in that order\n#\n# panic reasons are defined in `class PanicReason`\n#\n# Printing to the console is done through `print_message`. All `log_` functionality is purely for the logging system\n#\n#\n#\n#\n#\n# CODE STYLE\n# NOTE: THIS PLATFORM DOES NOT SUPPORT THE `typing` MODULE. THERE IS NO TYPE SAFETY. YOU ARE ON YOUR OWN. YOU HAVE BEEN WARNED.\n#\n#\n#\n#\n#\n# REST OF DOCS\n#\n# Our primary goal of this is to find a way to construct arbitrary paths between points\n# on a weighted grid. The grid size is defined by CONFIG_MAP_WIDTH and CONFIG_MAP_HEIGHT.\n#\n# Grid coordinates are structured as follows:\n#\n#\n# +y\n#\n# |\n# |\n# |\n# |\n# |\n# |\n# 0 ---------------- +x\n#\n# The bottom left is the origin, and it increases in the X direction going right, and the Y direction going up.\n#\n# NOTE: Gridlines are formed along the lines of tiles, NOT their centers. This means that the walls adjacent to\n# the origin are the X and Y axes.\n#\n# We will use the A* pathfinding algorithm, as this is weighted (if it wasn't weighted, we could probably do Jump Point Search)\n#\n# There are two main classes: `class Robot` and `class Path`. The `Robot` class is used to abstract over our Brain and Drivetrain\n# There are more internal classes, but don't worry about those as much, as those are not as core to the functionality\n#\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- IMPORTS ----------------------------------\n#\n#\n#\n#\n#\n#\n\nimport sys\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CONSTANTS ----------------------------------\n#\n#\n#\n#\n#\n#\n\n\nCONST_WEIGHT_UNTRAVERESABLE = -1\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CONFIG ----------------------------------\n#\n#\n#\n#\n#\n#\n\nCONFIG_DEBUG = (\n    True  # Defines if we are in a debug build. More logging functionality will be enabled if we are, but this\n)\nCONFIG_AUDIO_DIR = \"audio\"\n\n# May come at the cost of slowing down the program due to the instrumentation.\n\nCONFIG_MAP_WIDTH = 7  # Map width in units.\nCONFIG_MAP_HEIGHT = 7  # Map height in units.\n\nCONFIG_MAP_TILE_WIDTH_INCHES = 12  # TODO: measure these\nCONFIG_MAP_TILE_HEIGHT_INCHES = 12\n\n# TODO: Figure out what the robot's memory usage limitations are\n\n# These two variables exist to limit the size of the map.\n# The limits exist because internally we construct a large 2D array of `Tile`s to represent the map.\n# Computers have limited memory, so eventually it will OOM,\n# and these just exist to make sure we can safely exit before that happens\nCONFIG_CONST_MAX_WIDTH = 128\nCONFIG_CONST_MAX_HEIGHT = 128\n\n# This is an array of arrays of (weight, x, y). We parse this one time at init to label the obstacles on our map.\nCONFIG_MAP_OBSTACLES = [\n    [CONST_WEIGHT_UNTRAVERESABLE, 3, 1],\n    [CONST_WEIGHT_UNTRAVERESABLE, 2, 6],\n    [CONST_WEIGHT_UNTRAVERESABLE, 3, 3],\n    [CONST_WEIGHT_UNTRAVERESABLE, 5, 2],\n]  # Houses A, B, C, and D respectively\n\n# TODO: more configs for robot/arm speed and whatnot as they come about\n\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CODE ----------------------------------\n#\n#\n#\n#\n#\n#\n\n#\n#\n# --------- ERROR HANDLING AND INIT CODE ---------\n#\n#\n\n\n# Class definitions for error handling and init code\nclass InitStage:\n    INIT_CODE = 0  # Default init stage, only code is being set up\n    INIT_ROBOT = 1  # Initializing the robot to a known state\n    INIT_RUNNING = 2  # All systems go! (hopefully)\n\n\nclass PanicPhase:\n    PANIC_STOP_MOTION = 10  # Stop anything that might be running constantly\n    PANIC_SNAPSHOT_STATE = 20  # In case we need to know the current positions of things\n    PANIC_USER_DEBUG = 30  # Start the unwind and potentially enter a debug shell\n    PANIC_HALT = 40  # bye bye, basically the program halt\n\n\nclass PanicReason:\n    PANIC_UNKNOWN = 0\n\n    PANIC_MAP_OOB = 10\n    PANIC_MAP_CORRUPT = 11\n\n    PANIC_PATH_INVALID = 20\n    PANIC_PATH_NO_NEIGHBOR = 21\n\n    PANIC_ROBOT_ILLEGAL_MOVE = 30\n    PANIC_ROBOT_STATE_INVALID = 31\n\n    PANIC_COORD_INVALID = 40\n\n    PANIC_INTERNAL_INVARIANT = 100\n\n\nclass PanicCallback:\n    def __init__(\n        self,\n        name,\n        phase,\n        fn,\n        priority = 0,\n    ):\n        self.name = name\n        self.phase = phase\n        self.priority = priority\n        self.fn = fn\n\n\n_panic_callbacks = []\n\n# Init stage\n_init_stage = InitStage.INIT_CODE\n\n\ndef init_advance(stage):\n    global _init_stage\n    _init_stage = stage\n\ndef play_audio(file):\n    if file is None:\n        return\n\n    raw_path = CONFIG_AUDIO_DIR + \"/\" + file\n    if brain.sdcard.exists(raw_path):\n        brain.play_file(raw_path)\n        while brain.sound_is_active():\n            wait(5, MSEC)\n\ndef speak_number(num):\n    def speak_word(word):\n        play_audio(\"num_\" + word + \".wav\")\n\n    ones = [\n        \"\",\n        \"one\",\n        \"two\",\n        \"three\",\n        \"four\",\n        \"five\",\n        \"six\",\n        \"seven\",\n        \"eight\",\n        \"nine\",\n        \"ten\",\n        \"eleven\",\n        \"twelve\",\n        \"thirteen\",\n        \"fourteen\",\n        \"fifteen\",\n        \"sixteen\",\n        \"seventeen\",\n        \"eighteen\",\n        \"nineteen\",\n    ]\n\n    tens = [\n        \"\",\n        \"\",\n        \"twenty\",\n        \"thirty\",\n        \"forty\",\n        \"fifty\",\n        \"sixty\",\n        \"seventy\",\n        \"eighty\",\n        \"ninety\",\n    ]\n\n    print_message(str(num))\n    if num < 0 or num >= 1000:\n        return\n\n    if num == 0:\n        return speak_word(\"zero\")\n\n    if num >= 100:\n        one_part = ones[num / 100]\n        speak_word(one_part)\n        speak_word(\"hundred\")\n        num %= 100\n        if num > 0:\n            speak_word(\"and\")\n\n    if num >= 20:\n        speak_word(tens[num / 10])\n        num %= 10\n        if num > 0:\n            speak_word(ones[num])\n    elif num > 0:\n        speak_word(ones[num])\n\n\ndef get_time():\n    return 0  # TODO\n\n\ndef print_message(msg = \"\"):\n    print(msg)\n\n\n# This will terminate the program, it is UNSAFE to call from arbitrary points, and should only be invoked\n# from within `panic` unless something truly awful has happened and we cannot recover anything (unlikely)\ndef halt_and_catch_fire():\n    pass  # TODO: shutdown, lol\n\n\ndef panic(reason):\n    print_message('panic \"%s\"' % (reason))\n\n    callbacks = sorted(\n        _panic_callbacks,\n        key=lambda c: (c.phase, -c.priority),\n    )\n\n    for cb in callbacks:\n        try:\n            if CONFIG_DEBUG:\n                print_message(\"panic: %s:%s\" % (cb.phase.name, cb.name))\n            cb.fn()\n        except Exception as e:\n            print_message(\"panic callback %s failed: %s\" % (cb.name, e))\n\n    halt_and_catch_fire()\n\n\ndef panic_callback_register(cb):\n    _panic_callbacks.append(cb)\n\n\n# USE THIS to assert conditions\ndef robo_assert(condition, reason, msg = \"\"):\n    if condition:\n        return\n\n    panic(\"%s: %s\" % (reason.name, msg))\n\n\n# this only exists in case something goes VERY VERY WRONG TODO implement\ndef global_exception_handler(exc_type, exc, tb):\n    pass\n\n\n# sys.excepthook = global_exception_handler\n\n#\n#\n# --------- MAIN LOGIC ---------\n#\n#\n\n\n# Types\n# Coord = (int, int)  # x, y\n# TileWeight = int\n# Direction = (int, int)\nNORTH = (0, 1)\nSOUTH = (0, -1)\nEAST = (1, 0)\nWEST = (-1, 0)\n\n\nclass LogType:\n    LOG_TRACE = 0  # Trace events\n    LOG_DEBUG = 1  # Debugging messages\n    LOG_WARN = 2  # Warnings\n    LOG_ERR = 3  # Fatal errors (these do NOT panic, however)\n\n\nclass Log:\n    def __init__(self, log_type, message = \"\"):\n        self.log_type = log_type\n        self.message = message\n        self.time = get_time()\n\n\n_logs = []\n\n\ndef log_event(log_type, message = \"\"):\n    _logs.append(Log(log_type, message))\n\n\n# A \"Tile\" structure, this has a weight, which we define with __slots__\n# because there will be a LOT of these, and this is the only thing that a tile has.\nclass Tile:\n    __slots__ = (\"weight\",)\n\n    def __init__(self, weight):\n        self.weight = weight\n\n    # Negative weights are completely untraversable\n    @property\n    def traversable(self):\n        return self.weight >= 0\n\n    @property\n    def cost(self):\n        return self.weight\n\n\n# A \"GridMap\" structure to represent all the Tiles of the map\nclass GridMap:\n    def __init__(self, width, height):\n        robo_assert(\n            width <= CONFIG_CONST_MAX_WIDTH and height <= CONFIG_CONST_MAX_HEIGHT,\n            PanicReason.PANIC_MAP_OOB,\n            \"map size exceeds hard limits\",\n        )\n        self.width = width\n        self.height = height\n\n        # indexed as [y][x], or [row][col]\n        self.tiles = [\n            [Tile(1) for _ in range(width + 1)] for _ in range(height + 1)\n        ]\n\n    def in_bounds(self, coord):\n        x, y = coord\n        return 0 <= x <= self.width and 0 <= y <= self.height\n\n    def tile(self, coord):\n        x, y = coord\n        return self.tiles[y][x]\n\n    def neighbors(self, coord):\n        x, y = coord\n        candidates = [\n            (x + 1, y),  # eastern one\n            (x - 1, y),  # western one\n            (x, y + 1),  # northern one\n            (x, y - 1),  # southern one\n        ]\n\n        result = []\n        for c in candidates:\n            if self.in_bounds(c) and self.tile(c).traversable:\n                result.append(c)\n\n        return result\n\n\nclass Location:\n    def __init__(self, name, audio_file):\n        self.name = name\n        self.audio_file = audio_file\n\n    def speak(self):\n        play_audio(self.audio_file)\n\n\nclass Menu:\n    def __init__(self, locations):\n        robo_assert(len(locations) > 0, PanicReason.PANIC_INTERNAL_INVARIANT, \n                    \"Menu must have at least one location\")\n        self.locations = locations\n        self.current_location = locations[0]\n\n\n\n# No need to use __slots__ here, since these structures aren't as frequently\n# instantiated, and we might end up adding extra properties later on\nclass Path:\n    def __init__(self, points):\n        robo_assert(\n            len(points) != 0, PanicReason.PANIC_PATH_INVALID, \"path must have points\"\n        )\n        self.points = points\n\n    @property\n    def start(self):\n        return self.points[0]\n\n    @property\n    def end(self):\n        return self.points[-1]\n\n    def __len__(self):\n        return len(self.points)\n\n    def __iter__(self):\n        return iter(self.points)\n\n\n# ---------------------- ROBOT STATE MACHINE ----------------------\n#                         ┌───────────────┐                           \n#                         │               │                           \n#             ┌─INIT FAIL─│    STOPPED    │──INIT OK──┐               \n#             │           │               │           │               \n#             │           └───────────────┘           │               \n#             │                   ▲                   │               \n#             ▼                   │                   ▼               \n#   ┌───────────────────┐         │         ┌───────────────────┐     \n#   │                   │         │         │                   │     \n#   │    FAILED INIT    │         │         │    INITIALIZED    │     \n#   │                   │         │         │                   │     \n#   └───────────────────┘         │         └───────────────────┘     \n#             │                   │                   │               \n#             │                   │               ENTER MENU          \n#             └──RETURN BACK TO───┘                   ▼               \n#                                           ┌──────────────────┐      \n#                                           │                  │      \n#             ┌──RE-ENTER MENU──┬──────────▶│  SELECTION MENU  │◀─┐   \n#             │                 │           │                  │  │   \n#   ┌───────────────────┐       │           └──────────────────┘  │   \n#   │                   │       │                     │           │   \n#   │  DELIVER PACKAGE  │   PATH FAIL                 │           │   \n#   │                   │       │                     ├────STAY───┘   \n#   └───────────────────┘       │                     │               \n#             ▲                 │                     │               \n#             │          ┌────────────┐               │               \n#             │          │            │               │               \n#             └─PATH OK──│   TRAVEL   │◀───SELECTED───┘               \n#                        │            │                               \n#                        └────────────┘                               \n#                                                                     \n#                                                                     \n#                                ◎                                    \n#                                ╳                                    \n#                           STOP SIGNAL                               \n#                         (can arrive at                              \n#                            any time)                                \n#                                ╳                                    \n#                                ▼                                    \n#                        ┌───────────────┐                            \n#                        │               │                            \n#                        │    STOPPED    │                            \n#                        │               │                            \n#                        └───────────────┘                            \n\nclass RobotState:\n    ROBOT_FAILED_INIT = -1\n    ROBOT_STOPPED = 0\n    ROBOT_INITIALIZED = 1\n    ROBOT_IN_MENU = 2\n    ROBOT_TRAVELLING = 3\n    ROBOT_DELIVERING = 4\n\nclass Robot:\n    def __init__(self, start):\n        self.position = start\n        self.heading_deg = 0.0\n        self.state = RobotState.ROBOT_FAILED_INIT\n    \n    def change_state(self, new_state):\n        log_event(LogType.LOG_TRACE, \"Robot state change %s -> %s\" % (self.state.name, new_state.name))\n        self.state = new_state\n\n    def can_step_to(self, target):\n        x1, y1 = self.position\n        x2, y2 = target\n        return abs(x1 - x2) + abs(y1 - y2) == 1\n\n    def follow_path(self, path):\n        robo_assert(\n            path.start == self.position,\n            PanicReason.PANIC_PATH_INVALID,\n            \"path start %s does not match robot position %s\" % (path.start, self.position),\n        )\n\n        for next_coord in path.points[1:]:\n            robo_assert(\n                self.can_step_to(next_coord),\n                PanicReason.PANIC_PATH_INVALID,\n                \"illegal move from %s to %s\" % (self.position, next_coord),\n            )\n\n            self._move_to(next_coord)\n\n    def _move_to(self, coord):\n        if CONFIG_DEBUG:\n            print_message(\"moving from %s to %s\" % (self.position, coord))\n\n        # TODO: Drivetrain\n        self.position = coord\n\n\ndef reconstruct_path(came_from, current):\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    path.reverse()\n    return path\n\n\n# manhattan distance as we restrict ourselves to horizontal and vertical\ndef heuristic(a, b):\n    return abs(a[0] - b[0]) + abs(\n        a[1] - b[1]\n    )  # imagine having an algorithm named after your bad urban planning\n\n\ndef build_map_from_config():\n    grid = GridMap(CONFIG_MAP_WIDTH, CONFIG_MAP_HEIGHT)\n\n    for entry in CONFIG_MAP_OBSTACLES:\n        weight, x, y = entry\n        coord = (x, y)\n\n        robo_assert(\n            grid.in_bounds(coord),\n            PanicReason.PANIC_MAP_CORRUPT,\n            \"obstacle out of bounds: %s\" % (coord),\n        )\n\n        grid.tile(coord).weight = weight\n\n    return grid\n\nclass heapq:\n    def __init__(self):\n        self.data = []\n\n    def heappush(self, item):\n        self.data.append(item)\n        self.data.sort(key=lambda x: x[0])\n\n    def heappop(self):\n        return self.data.pop(0)\n\n    def __bool__(self):\n        return len(self.data) > 0\n\n\n\n# We're using an A* algorithm here to pathfind, however we have very strong bias\n# towards avoiding turning and prefer direct straight lines for error minimization\n\n# As an effect of this, this algorithm often behaves identically to a much simpler, more\n# naive \"drive forward to the right row, turn right, drive to right column\", especially\n# on smaller (e.g. 6x6) maps that have smaller turn costs.\n\n# However, we will preserve the use of A* in case we want to experiment with treating\n# smaller units as \"tiles\" (e.g. one virtual tile is not a physical tile on the ground)\n\n\n# This algorithm can also be unbiased to test different degrees of turn costs to time efficiency\ndef astar_with_directions(\n    grid,\n    start,\n    goal,\n    turn_cost = 5,\n    start_dir = None,\n    goal_dir = None,\n):\n    robo_assert(\n        grid.in_bounds(start) and grid.in_bounds(goal),\n        PanicReason.PANIC_COORD_INVALID,\n        \"start or goal out of bounds\",\n    )\n\n    if not grid.tile(goal).traversable:\n        grid.tile(goal).weight = (\n            0  # NOTE: We will allow going to untraversable locations because houses are\n            # untraversable along the way but can be a destination\n        )\n\n    if not grid.tile(start).traversable or not grid.tile(goal).traversable:\n        return None\n\n    # (f_score, Coord)\n    open_heap = []\n    heapq.heappush(open_heap, (0, start))\n\n    # path reconstruction\n    came_from = {}  # What tile did we come from?\n    came_from_dir = (\n        {}\n    )  # directions we came from to reach this node\n\n    if start_dir is not None:\n        came_from_dir[start] = start_dir  # set our starting direction if one exists\n\n    g_score = {start: 0}  # Cost to get to the current node\n\n    def get_direction(a, b):\n        return (b[0] - a[0], b[1] - a[1])\n\n    while open_heap:\n        _, current = heapq.heappop(\n            open_heap\n        )  # `current` is tile with lowest estimated cost\n\n        if current == goal:\n            path = Path(reconstruct_path(came_from, current))\n\n            if goal_dir is not None and len(path.points) >= 2:\n                final_dir = get_direction(path.points[-2], path.points[-1])\n                robo_assert(\n                    final_dir == goal_dir,\n                    PanicReason.PANIC_PATH_INVALID,\n                    \"goal orientation unsatisfiable\",  # face the required direction\n                )\n\n            return path\n\n        # check N, S, E, W neighbors from us\n        for neighbor in grid.neighbors(current):\n            tentative_g = g_score[current] + grid.tile(neighbor).cost\n            move_dir = get_direction(current, neighbor)\n\n            prev_dir = came_from_dir.get(current)\n\n            # this would require a turn, so we bias it away\n            if prev_dir is not None and move_dir != prev_dir:\n                tentative_g += turn_cost\n\n            # if this neighbor is unvisited OR if we have found a cheaper path than before,\n            # update things and continue from the big outer loop\n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                came_from[neighbor] = current\n                came_from_dir[neighbor] = move_dir\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(\n                    neighbor, goal\n                )  # heuristic is estimated cost from here to goal\n                heapq.heappush(open_heap, (f_score, neighbor))\n\n    robo_assert(False, PanicReason.PANIC_PATH_INVALID, \"no path found\")\n    return None\n","textLanguage":"python","robotConfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[3,8,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"wheel4in","gearRatio":"1:1","direction":"fwd","gyroType":"integrated","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null}],"slot":0,"platform":"EXP","sdkVersion":"20240802.15.00.00","appVersion":"4.64.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}