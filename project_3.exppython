{"mode":"Text","hardwareTarget":"brain","textContent":"# Before we start, let's define the layout for this file\n#\n# We are taking on this structure of a monolithic self-contained python file to make everyone's life\n# a little easier, since one can simply share this singular file\n#\n# DOCUMENTATION - Comments explaining the high-level \"Design\" of this file, further comments will be found later on in CODE\n#\n# IMPORTS - our library imports\n#\n# UNMODIFIABLE CONSTANTS - for things like sentinel values, prefixed with CONST_\n#\n# CONFIGURATION - global CONFIG_ variables\n#\n# CODE - Implementation\n#\n#        Throughout CODE, init code will be sprinkled around to initialize and declare global variables.\n#        HOWEVER, no actual code will run until the very end of the section.\n#\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- DOCUMENTATION ----------------------------------\n#\n#\n#\n#\n#\n#\n\n# IMPORTANT NOTES\n# Global variables with `_` prefixed in their name should NOT\n# be modified from other systems. Only modify global variables prefixed with `CONFIG_`.\n#\n#\n#\n# ERROR HANDLING\n# We will be using a custom `robo_assert` as opposed to the error `raise` paradigm of Python.\n# This is because with the `raise` paradigm, we are either relying on the caller to always\n# remember to `try...catch`, or are relying on one big `try...catch` in the main outer loop.\n#\n# This kind of code structure can easily break from a forgotten statement, and such moments\n# can lead to undefined behavior within the robot. Thus, we choose to use `robo_assert` as it\n# gives us strict determinism, and isolates our code's errors from the robot's errors, as we can\n# know that any `raise` would not arise from errors that we created (since we go through `robo_assert`)\n#\n# `robo_assert` takes in an asserted statement, panic reason, and message, in that order\n#\n# panic reasons are defined in `class PanicReason`\n#\n# Printing to the console is done through `print_message`. All `log_` functionality is purely for the logging system\n#\n#\n#\n#\n#\n# CODE STYLE\n# Because python is duck typed by default (https://en.wikipedia.org/wiki/Duck_typing),\n# please give GLOBAL variables and function parameters explicit types when declared.\n#\n# Return types only have to be annotated if they are NOT `None`\n#\n#\n#\n#\n#\n# REST OF DOCS\n#\n# Our primary goal of this is to find a way to construct arbitrary paths between points\n# on a weighted grid. The grid size is defined by CONFIG_MAP_WIDTH and CONFIG_MAP_HEIGHT.\n#\n# Grid coordinates are structured as follows:\n#\n#\n# +y\n#\n# |\n# |\n# |\n# |\n# |\n# |\n# 0 ---------------- +x\n#\n# The bottom left is the origin, and it increases in the X direction going right, and the Y direction going up.\n#\n# NOTE: Gridlines are formed along the lines of tiles, NOT their centers. This means that the walls adjacent to\n# the origin are the X and Y axes.\n#\n# We will use the A* pathfinding algorithm, as this is weighted (if it wasn't weighted, we could probably do Jump Point Search)\n#\n# There are two main classes: `class Robot` and `class Path`. The `Robot` class is used to abstract over our Brain and Drivetrain\n# There are more internal classes, but don't worry about those as much, as those are not as core to the functionality\n#\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- IMPORTS ----------------------------------\n#\n#\n#\n#\n#\n#\n\nimport sys\nimport heapq\nfrom typing import Dict, Optional, List, Tuple, Callable  # we have type safety at home\nfrom enum import IntEnum\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CONSTANTS ----------------------------------\n#\n#\n#\n#\n#\n#\n\n\nCONST_WEIGHT_UNTRAVERESABLE = -1\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CONFIG ----------------------------------\n#\n#\n#\n#\n#\n#\n\nCONFIG_DEBUG: bool = (\n    True  # Defines if we are in a debug build. More logging functionality will be enabled if we are, but this\n)\nCONFIG_AUDIO_DIR = \"audio\"\n\n# May come at the cost of slowing down the program due to the instrumentation.\n\nCONFIG_MAP_WIDTH: int = 7  # Map width in units.\nCONFIG_MAP_HEIGHT: int = 7  # Map height in units.\n\nCONFIG_MAP_TILE_WIDTH_INCHES: int = 12  # TODO: measure these\nCONFIG_MAP_TILE_HEIGHT_INCHES: int = 12\n\n# TODO: Figure out what the robot's memory usage limitations are\n\n# These two variables exist to limit the size of the map.\n# The limits exist because internally we construct a large 2D array of `Tile`s to represent the map.\n# Computers have limited memory, so eventually it will OOM,\n# and these just exist to make sure we can safely exit before that happens\nCONFIG_CONST_MAX_WIDTH: int = 128\nCONFIG_CONST_MAX_HEIGHT: int = 128\n\n# This is an array of arrays of (weight, x, y). We parse this one time at init to label the obstacles on our map.\nCONFIG_MAP_OBSTACLES: List[List] = [\n    [CONST_WEIGHT_UNTRAVERESABLE, 3, 1],\n    [CONST_WEIGHT_UNTRAVERESABLE, 2, 6],\n    [CONST_WEIGHT_UNTRAVERESABLE, 3, 3],\n    [CONST_WEIGHT_UNTRAVERESABLE, 5, 2],\n]  # Houses A, B, C, and D respectively\n\n# TODO: more configs for robot/arm speed and whatnot as they come about\n\n\n#\n#\n#\n#\n#\n#\n# ---------------------------------- CODE ----------------------------------\n#\n#\n#\n#\n#\n#\n\n#\n#\n# --------- ERROR HANDLING AND INIT CODE ---------\n#\n#\n\n\n# Class definitions for error handling and init code\nclass InitStage(IntEnum):\n    INIT_CODE = 0  # Default init stage, only code is being set up\n    INIT_ROBOT = 1  # Initializing the robot to a known state\n    INIT_RUNNING = 2  # All systems go! (hopefully)\n\n\nclass PanicPhase(IntEnum):\n    PANIC_STOP_MOTION = 10  # Stop anything that might be running constantly\n    PANIC_SNAPSHOT_STATE = 20  # In case we need to know the current positions of things\n    PANIC_USER_DEBUG = 30  # Start the unwind and potentially enter a debug shell\n    PANIC_HALT = 40  # bye bye, basically the program halt\n\n\nclass PanicReason(IntEnum):\n    PANIC_UNKNOWN = 0\n\n    PANIC_MAP_OOB = 10\n    PANIC_MAP_CORRUPT = 11\n\n    PANIC_PATH_INVALID = 20\n    PANIC_PATH_NO_NEIGHBOR = 21\n\n    PANIC_ROBOT_ILLEGAL_MOVE = 30\n    PANIC_ROBOT_STATE_INVALID = 31\n\n    PANIC_COORD_INVALID = 40\n\n    PANIC_INTERNAL_INVARIANT = 100\n\n\nclass PanicCallback:\n    def __init__(\n        self,\n        name: str,\n        phase: PanicPhase,\n        fn: Callable[[], None],\n        priority: int = 0,\n    ):\n        self.name = name\n        self.phase = phase\n        self.priority = priority\n        self.fn = fn\n\n\n_panic_callbacks: list[PanicCallback] = []\n\n# Init stage\n_init_stage = InitStage.INIT_CODE\n\n\ndef init_advance(stage: InitStage):\n    global _init_stage\n    _init_stage = stage\n\n\ndef audio_file_to_path(file: str) -> str:\n    return CONFIG_AUDIO_DIR + \"/\" + file\n\n\ndef play_audio(file: Optional[str]):\n    if file is None:\n        return\n\n    pass  # TODO\n\n\ndef speak_number(num: int):\n    def speak_word(word: str):\n        play_audio(audio_file_to_path(\"robot_num_\" + word + \".wav\"))\n\n    ones = [\n        \"\",\n        \"one\",\n        \"two\",\n        \"three\",\n        \"four\",\n        \"five\",\n        \"six\",\n        \"seven\",\n        \"eight\",\n        \"nine\",\n        \"ten\",\n        \"eleven\",\n        \"twelve\",\n        \"thirteen\",\n        \"fourteen\",\n        \"fifteen\",\n        \"sixteen\",\n        \"seventeen\",\n        \"eighteen\",\n        \"nineteen\",\n    ]\n\n    tens = [\n        \"\",\n        \"\",\n        \"twenty\",\n        \"thirty\",\n        \"forty\",\n        \"fifty\",\n        \"sixty\",\n        \"seventy\",\n        \"eighty\",\n        \"ninety\",\n    ]\n\n    print_message(f\"{num}\")\n    if num < 0 or num >= 1000:\n        return\n\n    if num == 0:\n        return speak_word(\"zero\")\n\n    if num >= 100:\n        one_part = ones[num / 100]\n        speak_word(one_part)\n        speak_word(\"hundred\")\n        num %= 100\n        if num > 0:\n            speak_word(\"and\")\n\n    if num >= 20:\n        speak_word(tens[num / 10])\n        num %= 10\n        if num > 0:\n            speak_word(ones[num])\n    elif num > 0:\n        speak_word(ones[num])\n\n\ndef get_time() -> int:\n    return 0  # TODO\n\n\ndef print_message(msg: str = \"\"):\n    print(msg)\n\n\n# This will terminate the program, it is UNSAFE to call from arbitrary points, and should only be invoked\n# from within `panic` unless something truly awful has happened and we cannot recover anything (unlikely)\ndef halt_and_catch_fire():\n    pass  # TODO: shutdown, lol\n\n\ndef panic(reason: str):\n    print_message(f'panic \"{reason}\"')\n\n    callbacks = sorted(\n        _panic_callbacks,\n        key=lambda c: (c.phase, -c.priority),\n    )\n\n    for cb in callbacks:\n        try:\n            if CONFIG_DEBUG:\n                print_message(f\"panic: {cb.phase.name}:{cb.name}\")\n            cb.fn()\n        except Exception as e:\n            print_message(f\"panic callback {cb.name} failed: {e}\")\n\n    halt_and_catch_fire()\n\n\ndef panic_callback_register(cb: PanicCallback):\n    _panic_callbacks.append(cb)\n\n\n# USE THIS to assert conditions\ndef robo_assert(condition: bool, reason: PanicReason, msg: str = \"\"):\n    if condition:\n        return\n\n    panic(f\"{reason.name}: {msg}\")\n\n\n# this only exists in case something goes VERY VERY WRONG TODO implement\ndef global_exception_handler(exc_type, exc, tb):\n    pass\n\n\nsys.excepthook = global_exception_handler\n\n#\n#\n# --------- MAIN LOGIC ---------\n#\n#\n\n\n# Types\nCoord = Tuple[int, int]  # x, y\nTileWeight = int\nDirection = Tuple[int, int]\nNORTH: Direction = (0, 1)\nSOUTH: Direction = (0, -1)\nEAST: Direction = (1, 0)\nWEST: Direction = (-1, 0)\n\n\nclass LogType(IntEnum):\n    LOG_TRACE = 0  # Trace events\n    LOG_DEBUG = 1  # Debugging messages\n    LOG_WARN = 2  # Warnings\n    LOG_ERR = 3  # Fatal errors (these do NOT panic, however)\n\n\nclass Log:\n    def __init__(self, log_type: LogType, message: str = \"\"):\n        self.log_type = log_type\n        self.message = message\n        self.time = get_time()\n\n\n_logs: List[Log] = []\n\n\ndef log_event(log_type: LogType, message: str = \"\"):\n    _logs.append(Log(log_type, message))\n\n\n# A \"Tile\" structure, this has a weight, which we define with __slots__\n# because there will be a LOT of these, and this is the only thing that a tile has.\nclass Tile:\n    __slots__ = (\"weight\",)\n\n    def __init__(self, weight: TileWeight):\n        self.weight: TileWeight = weight\n\n    # Negative weights are completely untraversable\n    @property\n    def traversable(self) -> bool:\n        return self.weight >= 0\n\n    @property\n    def cost(self) -> int:\n        return self.weight\n\n\n# A \"GridMap\" structure to represent all the Tiles of the map\nclass GridMap:\n    def __init__(self, width: int, height: int):\n        robo_assert(\n            width <= CONFIG_CONST_MAX_WIDTH and height <= CONFIG_CONST_MAX_HEIGHT,\n            PanicReason.PANIC_MAP_OOB,\n            \"map size exceeds hard limits\",\n        )\n        self.width: int = width\n        self.height: int = height\n\n        # indexed as [y][x], or [row][col]\n        self.tiles: List[List[Tile]] = [\n            [Tile(1) for _ in range(width + 1)] for _ in range(height + 1)\n        ]\n\n    def in_bounds(self, coord: Coord) -> bool:\n        x, y = coord\n        return 0 <= x <= self.width and 0 <= y <= self.height\n\n    def tile(self, coord: Coord) -> Tile:\n        x, y = coord\n        return self.tiles[y][x]\n\n    def neighbors(self, coord: Coord) -> List[Coord]:\n        x, y = coord\n        candidates = [\n            (x + 1, y),  # eastern one\n            (x - 1, y),  # western one\n            (x, y + 1),  # northern one\n            (x, y - 1),  # southern one\n        ]\n\n        result: List[Coord] = []\n        for c in candidates:\n            if self.in_bounds(c) and self.tile(c).traversable:\n                result.append(c)\n\n        return result\n\n\nclass Location:\n    def __init__(self, name: str, audio_file: Optional[str]):\n        self.name = name\n        self.audio_file = audio_file\n\n    def speak(self):\n        play_audio(audio_file_to_path(self.audio_file))\n\n\nclass Menu:\n    def __init__(self, locations: List[Location]):\n        pass\n\n\n# No need to use __slots__ here, since these structures aren't as frequently\n# instantiated, and we might end up adding extra properties later on\nclass Path:\n    def __init__(self, points: List[Coord]):\n        robo_assert(\n            len(points) != 0, PanicReason.PANIC_PATH_INVALID, \"path must have points\"\n        )\n        self.points: List[Coord] = points\n\n    @property\n    def start(self) -> Coord:\n        return self.points[0]\n\n    @property\n    def end(self) -> Coord:\n        return self.points[-1]\n\n    def __len__(self) -> int:\n        return len(self.points)\n\n    def __iter__(self):\n        return iter(self.points)\n\n\nclass Robot:\n    def __init__(self, start: Coord):\n        self.position: Coord = start\n        self.heading_deg: float = 0.0\n\n    def can_step_to(self, target: Coord) -> bool:\n        x1, y1 = self.position\n        x2, y2 = target\n        return abs(x1 - x2) + abs(y1 - y2) == 1\n\n    def follow_path(self, path: Path):\n        robo_assert(\n            path.start == self.position,\n            PanicReason.PANIC_PATH_INVALID,\n            f\"path start {path.start} does not match robot position {self.position}\",\n        )\n\n        for next_coord in path.points[1:]:\n            robo_assert(\n                self.can_step_to(next_coord),\n                PanicReason.PANIC_PATH_INVALID,\n                f\"illegal move from {self.position} to {next_coord}\",\n            )\n\n            self._move_to(next_coord)\n\n    def _move_to(self, coord: Coord):\n        if CONFIG_DEBUG:\n            print(f\"moving from {self.position} to {coord}\")\n\n        # TODO: Drivetrain\n        self.position = coord\n\n\ndef reconstruct_path(came_from: dict[Coord, Coord], current: Coord) -> List[Coord]:\n    path = [current]\n    while current in came_from:\n        current = came_from[current]\n        path.append(current)\n    path.reverse()\n    return path\n\n\n# manhattan distance as we restrict ourselves to horizontal and vertical\ndef heuristic(a: Coord, b: Coord) -> int:\n    return abs(a[0] - b[0]) + abs(\n        a[1] - b[1]\n    )  # imagine having an algorithm named after your bad urban planning\n\n\ndef build_map_from_config() -> GridMap:\n    grid = GridMap(CONFIG_MAP_WIDTH, CONFIG_MAP_HEIGHT)\n\n    for entry in CONFIG_MAP_OBSTACLES:\n        weight, x, y = entry\n        coord: Coord = (x, y)\n\n        robo_assert(\n            grid.in_bounds(coord),\n            PanicReason.PANIC_MAP_CORRUPT,\n            f\"obstacle out of bounds: {coord}\",\n        )\n\n        grid.tile(coord).weight = weight\n\n    return grid\n\n\n# We're using an A* algorithm here to pathfind, however we have very strong bias\n# towards avoiding turning and prefer direct straight lines for error minimization\n\n# As an effect of this, this algorithm often behaves identically to a much simpler, more\n# naive \"drive forward to the right row, turn right, drive to right column\", especially\n# on smaller (e.g. 6x6) maps that have smaller turn costs.\n\n# However, we will preserve the use of A* in case we want to experiment with treating\n# smaller units as \"tiles\" (e.g. one virtual tile is not a physical tile on the ground)\n\n\n# This algorithm can also be unbiased to test different degrees of turn costs to time efficiency\ndef astar_with_directions(\n    grid: GridMap,\n    start: Coord,\n    goal: Coord,\n    turn_cost: int = 5,\n    start_dir: Optional[Direction] = None,\n    goal_dir: Optional[Direction] = None,\n) -> Optional[Path]:\n    robo_assert(\n        grid.in_bounds(start) and grid.in_bounds(goal),\n        PanicReason.PANIC_COORD_INVALID,\n        \"start or goal out of bounds\",\n    )\n\n    if not grid.tile(goal).traversable:\n        grid.tile(goal).weight = (\n            0  # NOTE: We will allow going to untraversable locations because houses are\n            # untraversable along the way but can be a destination\n        )\n\n    if not grid.tile(start).traversable or not grid.tile(goal).traversable:\n        return None\n\n    # (f_score, Coord)\n    open_heap: List[Tuple[int, Coord]] = []\n    heapq.heappush(open_heap, (0, start))\n\n    # path reconstruction\n    came_from: Dict[Coord, Coord] = {}  # What tile did we come from?\n    came_from_dir: Dict[Coord, Direction] = (\n        {}\n    )  # directions we came from to reach this node\n\n    if start_dir is not None:\n        came_from_dir[start] = start_dir  # set our starting direction if one exists\n\n    g_score: Dict[Coord, int] = {start: 0}  # Cost to get to the current node\n\n    def get_direction(a: Coord, b: Coord) -> Direction:\n        return (b[0] - a[0], b[1] - a[1])\n\n    while open_heap:\n        _, current = heapq.heappop(\n            open_heap\n        )  # `current` is tile with lowest estimated cost\n\n        if current == goal:\n            path = Path(reconstruct_path(came_from, current))\n\n            if goal_dir is not None and len(path.points) >= 2:\n                final_dir = get_direction(path.points[-2], path.points[-1])\n                robo_assert(\n                    final_dir == goal_dir,\n                    PanicReason.PANIC_PATH_INVALID,\n                    \"goal orientation unsatisfiable\",  # face the required direction\n                )\n\n            return path\n\n        # check N, S, E, W neighbors from us\n        for neighbor in grid.neighbors(current):\n            tentative_g = g_score[current] + grid.tile(neighbor).cost\n            move_dir = get_direction(current, neighbor)\n\n            prev_dir = came_from_dir.get(current)\n\n            # this would require a turn, so we bias it away\n            if prev_dir is not None and move_dir != prev_dir:\n                tentative_g += turn_cost\n\n            # if this neighbor is unvisited OR if we have found a cheaper path than before,\n            # update things and continue from the big outer loop\n            if neighbor not in g_score or tentative_g < g_score[neighbor]:\n                came_from[neighbor] = current\n                came_from_dir[neighbor] = move_dir\n                g_score[neighbor] = tentative_g\n                f_score = tentative_g + heuristic(\n                    neighbor, goal\n                )  # heuristic is estimated cost from here to goal\n                heapq.heappush(open_heap, (f_score, neighbor))\n\n    robo_assert(False, PanicReason.PANIC_PATH_INVALID, \"no path found\")\n    return None\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"EXP","sdkVersion":"20240802.15.00.00","appVersion":"4.64.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}